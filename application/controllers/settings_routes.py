# Copyright (C) 2021-2025 tiksan
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import base64
import datetime
import hashlib
import os
import time
import typing

from flask import Blueprint, Response, redirect, render_template, request, session
from flask_login import current_user, fresh_login_required
from peewee import DoesNotExist
from tornium_commons.models import OAuthClient, OAuthToken, TornKey, User

import utils.totp
from controllers.api.v1.utils import make_exception_response
from controllers.decorators import session_required, token_required

mod = Blueprint("settings_routes", __name__)


@mod.route("/settings")
@fresh_login_required
@token_required(setnx=True)
def settings(*args, **kwargs):
    if current_user.key is None:
        obfuscated_key = "Not Set"
    else:
        obfuscated_key = current_user.key[:6] + "*" * 10

    api_keys = list(
        k
        for k in TornKey.select(
            TornKey.guid,
            TornKey.api_key,
            TornKey.access_level,
            TornKey.disabled,
            TornKey.paused,
            TornKey.default,
        )
        .join(User)
        .where(TornKey.user.tid == current_user.tid)
    )

    # Applications the user has authorized are:
    #  - belonging to the user
    #  - have a not-revoked access token OR have a not-revoked refresh token
    applications = list(
        token
        for token in OAuthToken.select()
        .distinct(OAuthToken.client)
        .where(
            (OAuthToken.user == current_user.tid)
            & (
                (OAuthToken.access_token_revoked_at.is_null(True))
                | (OAuthToken.refresh_token.is_null(False) & (OAuthToken.refresh_token_revoked_at.is_null(True)))
            )
        )
        .order_by(OAuthToken.client.asc(), OAuthToken.issued_at)
    )

    return render_template(
        "settings/settings.html",
        obfuscated_key=obfuscated_key,
        api_keys=api_keys,
        applications=applications,
        discord_linked=("Not Linked" if current_user.discord_id in ("", None, 0) else "Linked"),
    )


@mod.route("/settings/application/<application_id>")
@fresh_login_required
@token_required(setnx=False)
def settings_application(application_id: str, *args, **kwargs):
    try:
        current_token: OAuthToken = (
            OAuthToken.select()
            .where(
                (OAuthToken.user == current_user.tid)
                & (OAuthToken.client == application_id)
                & (
                    (OAuthToken.access_token_revoked_at.is_null(True))
                    | (OAuthToken.refresh_token.is_null(False) & (OAuthToken.refresh_token_revoked_at.is_null(True)))
                )
            )
            .order_by(OAuthToken.issued_at.desc())
            .get()
        )
        first_token: OAuthToken = (
            OAuthToken.select()
            .where((OAuthToken.user == current_user.tid) & (OAuthToken.client == application_id))
            .order_by(OAuthToken.issued_at.asc())
            .get()
        )
    except DoesNotExist:
        return (
            render_template(
                "errors/error.html",
                title="Invalid Application ID",
                error="You have not authorized any application with this ID.",
            ),
            404,
        )

    scopes = current_token.scope.split()

    return render_template(
        "settings/application.html", current_token=current_token, first_token=first_token, scopes=scopes
    )


@mod.route("/settings/totp/setup", methods=["GET"])
@fresh_login_required
def load_setup_totp_page(*args, **kwargs):
    if current_user.security not in (0, None) and current_user.otp_secret not in (None, ""):
        return (
            render_template(
                "errors/error.html",
                title="TOTP Already Configured",
                error="TOTP has already been configured for your user account. Disable it before attempting to set it up.",
            ),
            400,
        )

    new_totp_secret = base64.b32encode(os.urandom(10)).decode("utf-8")
    new_totp_uri = f"otpauth://totp/Tornium:{current_user.tid}?secret={new_totp_secret}&Issuer=Tornium"

    # This will ensure that only valid TOTP secrets generated by the server can be added to the database.
    # Additionally secrets will expire after 15 minutes or until any secret is successfully used.
    secrets = session.get("new_totp_secrets") or []
    secrets.append((new_totp_secret, (time.time() + 60 * 15)))
    session["new_totp_secrets"] = secrets

    return render_template("settings/totp-setup.html", totp_secret=new_totp_secret, totp_uri=new_totp_uri)


@mod.route("/settings/totp/setup", methods=["POST"])
@fresh_login_required
def setup_totp(*args, **kwargs):
    if current_user.security not in (0, None) and current_user.otp_secret not in (None, ""):
        return (
            render_template(
                "errors/error.html",
                title="TOTP Already Configured",
                error="TOTP has already been configured for your user account. Disable it before attempting to set it up.",
            ),
            400,
        )

    token = request.form.get("totp-token")

    secrets = session.get("new_totp_secrets") or []
    secrets = [secret for secret in secrets if secret[1] > time.time()]
    session["new_totp_secrets"] = secrets

    valid_secret: typing.Optional[str] = None
    for secret in secrets:
        # Tokens that are valid for the secret
        secret_tokens = utils.totp.totp(secret[0])

        if token not in secret_tokens:
            continue

        valid_secret = secret[0]
        break

    if valid_secret is None:
        return (
            render_template(
                "errors/error.html",
                title="Invalid Token",
                error="The inputted token does not match the secret(s) for the session.",
            ),
            403,
        )

    session.pop("new_totp_secrets")

    User.update(otp_secret=valid_secret, security=1).where(User.tid == current_user.tid).execute()

    return redirect("/settings", code=302)


@mod.route("/settings/totp/disable", methods=["POST"])
@fresh_login_required
@session_required
def disable_totp(*args, **kwargs):
    if current_user.security in (0, None) or current_user.otp_secret in (None, ""):
        return (
            render_template(
                "errors/error.html",
                title="TOTP Not Configured",
                error="TOTP has not yet been configured for your user account.",
            ),
            400,
        )

    User.update(otp_secret=None, security=0).where(User.tid == current_user.tid).execute()

    return redirect("/settings", code=302)


@mod.route("/settings/totp/backup", methods=["POST"])
@fresh_login_required
@session_required
def regenerate_backup_codes(*args, **kwargs):
    if current_user.security in (0, None) or current_user.otp_secret in (None, ""):
        return (
            render_template(
                "errors/error.html",
                title="TOTP Not Configured",
                error="TOTP has not yet been configured for your user account.",
            ),
            400,
        )

    codes = []
    hashed_codes = []

    for _ in range(10):
        codes.append(base64.b32encode(os.urandom(10)).decode("utf-8"))

    for code in codes:
        hashed_codes.append(hashlib.sha256(code.encode("utf-8")).hexdigest())

    # We only want to store the hashed codes and not the codes themselves in case the hashed codes are leaked
    User.update(otp_backups=hashed_codes).where(User.tid == current_user.tid).execute()

    return Response(
        "\n".join(codes),
        mimetype="text/plain",
        headers={"Content-Disposition": "attachment;filename=tornium-backup-codes"},
    )


@mod.route("/oauth/client/<client_id>/revoke", methods=["POST"])
@fresh_login_required
@session_required
def revoke_client(client_id: str, *args, **kwargs):
    if not OAuthClient.select().where(OAuthClient.client_id == client_id).exists():
        return make_exception_response("0000", details={"message": "Invalid OAuth client ID"})

    OAuthToken.update(access_token_revoked_at=datetime.datetime.utcnow()).where(
        (OAuthToken.client == client_id) & (OAuthToken.access_token_revoked_at.is_null(True))
    ).execute()
    OAuthToken.update(refresh_token_revoked_at=datetime.datetime.utcnow()).where(
        (OAuthToken.client == client_id)
        & (OAuthToken.refresh_token.is_null(False))
        & (OAuthToken.refresh_token_revoked_at.is_null(True))
    ).execute()

    return make_exception_response("0001")
